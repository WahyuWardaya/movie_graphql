package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"errors"
	"fmt"
	"movie_api/config"
	"movie_api/graph/model"
	"movie_api/models"
	"movie_api/utils"

	"golang.org/x/crypto/bcrypt"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	// Validasi confirm password
	if input.Password != input.ConfirmPassword {
		return nil, errors.New("password dan confirm password tidak sama")
	}

	// Cek apakah email sudah digunakan
	var existing models.Users
	if err := config.DB.Where("users_email = ?", input.Email).First(&existing).Error; err == nil {
		return nil, errors.New("email sudah digunakan")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, errors.New("gagal hash password")
	}

	// Buat user baru
	newUser := models.Users{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		IDRoles:  uint(input.RoleID), // <- tetap gunakan input.RoleId agar fleksibel
	}

	if err := config.DB.Create(&newUser).Error; err != nil {
		return nil, errors.New("gagal menyimpan user")
	}

	// Ambil data role
	var role models.Roles
	if err := config.DB.First(&role, newUser.IDRoles).Error; err != nil {
		return nil, errors.New("gagal mengambil data role")
	}

	// Generate JWT
	token, err := utils.GenerateJWT(newUser.ID, newUser.Email, role.Name)
	if err != nil {
		return nil, errors.New("gagal membuat token")
	}

	// Kembalikan response
	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:    fmt.Sprintf("%d", newUser.ID),
			Name:  newUser.Name,
			Email: newUser.Email,
			Role: &model.Role{
				ID:   fmt.Sprintf("%d", role.ID),
				Name: role.Name,
			},
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthResponse, error) {
	var user models.Users

	// Cari user berdasarkan email
	if err := config.DB.Where("users_email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("email tidak ditemukan")
	}

	// Cek password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return nil, errors.New("password salah")
	}

	// Ambil role
	var role models.Roles
	if err := config.DB.First(&role, user.IDRoles).Error; err != nil {
		return nil, errors.New("gagal ambil role")
	}

	// Generate token
	token, err := utils.GenerateJWT(user.ID, user.Email, role.Name)
	if err != nil {
		return nil, errors.New("gagal membuat token")
	}

	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:    fmt.Sprint(user.ID),
			Name:  user.Name,
			Email: user.Email,
			Role: &model.Role{
				ID:   fmt.Sprint(role.ID),
				Name: role.Name,
			},
		},
	}, nil
}

// CreateActor is the resolver for the createActor field.
func (r *mutationResolver) CreateActor(ctx context.Context, input model.NewActor) (*model.Actor, error) {
	actor := models.Actors{Name: input.Name}
	if input.Photo != nil {
		actor.Photo = *input.Photo
	}
	if err := config.DB.Create(&actor).Error; err != nil {
		return nil, err
	}

	return &model.Actor{
		ID:    fmt.Sprint(actor.ID),
		Name:  actor.Name,
		Photo: actor.Photo, // ✅ kembalikan ke client
	}, nil
}

// CreateActors is the resolver for the createActors field.
func (r *mutationResolver) CreateActors(ctx context.Context, inputs []*model.NewActor) ([]*model.Actor, error) {
	var createdActors []*model.Actor

	for _, input := range inputs {
		actor := models.Actors{Name: input.Name}
		if input.Photo != nil {
			actor.Photo = *input.Photo
		}

		if err := config.DB.Create(&actor).Error; err != nil {
			return nil, err
		}

		createdActors = append(createdActors, &model.Actor{
			ID:    fmt.Sprint(actor.ID),
			Name:  actor.Name,
			Photo: actor.Photo,
		})
	}

	return createdActors, nil
}

// UpdateActor is the resolver for the updateActor field.
func (r *mutationResolver) UpdateActor(ctx context.Context, id string, input model.NewActor) (*model.Actor, error) {
	var actor models.Actors
	if err := config.DB.First(&actor, id).Error; err != nil {
		return nil, err
	}

	actor.Name = input.Name
	if input.Photo != nil {
		actor.Photo = *input.Photo
	}

	if err := config.DB.Save(&actor).Error; err != nil {
		return nil, err
	}

	return &model.Actor{
		ID:    fmt.Sprint(actor.ID),
		Name:  actor.Name,
		Photo: actor.Photo,
	}, nil
}

// DeleteActor is the resolver for the deleteActor field.
func (r *mutationResolver) DeleteActor(ctx context.Context, id string) (bool, error) {
	if err := config.DB.Delete(&models.Actors{}, id).Error; err != nil {
		return false, err
	}
	return true, nil
}

// CreateGenre is the resolver for the createGenre field.
func (r *mutationResolver) CreateGenre(ctx context.Context, input model.NewGenre) (*model.Genre, error) {
	panic(fmt.Errorf("not implemented: CreateGenre - createGenre"))
}

// UpdateGenre is the resolver for the updateGenre field.
func (r *mutationResolver) UpdateGenre(ctx context.Context, id string, input model.NewGenre) (*model.Genre, error) {
	panic(fmt.Errorf("not implemented: UpdateGenre - updateGenre"))
}

// DeleteGenre is the resolver for the deleteGenre field.
func (r *mutationResolver) DeleteGenre(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteGenre - deleteGenre"))
}

// CreateMovie is the resolver for the createMovie field.
func (r *mutationResolver) CreateMovie(ctx context.Context, input model.CreateMovieInput) (*model.Movie, error) {
	panic(fmt.Errorf("not implemented: CreateMovie - createMovie"))
}

// UpdateMovie is the resolver for the updateMovie field.
func (r *mutationResolver) UpdateMovie(ctx context.Context, id string, input model.UpdateMovieInput) (*model.Movie, error) {
	panic(fmt.Errorf("not implemented: UpdateMovie - updateMovie"))
}

// DeleteMovie is the resolver for the deleteMovie field.
func (r *mutationResolver) DeleteMovie(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteMovie - deleteMovie"))
}

// CreateBroadcast is the resolver for the createBroadcast field.
func (r *mutationResolver) CreateBroadcast(ctx context.Context, input model.NewBroadcast) (*model.Broadcast, error) {
	panic(fmt.Errorf("not implemented: CreateBroadcast - createBroadcast"))
}

// UpdateBroadcast is the resolver for the updateBroadcast field.
func (r *mutationResolver) UpdateBroadcast(ctx context.Context, id string, input model.NewBroadcast) (*model.Broadcast, error) {
	panic(fmt.Errorf("not implemented: UpdateBroadcast - updateBroadcast"))
}

// DeleteBroadcast is the resolver for the deleteBroadcast field.
func (r *mutationResolver) DeleteBroadcast(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteBroadcast - deleteBroadcast"))
}

// Movies is the resolver for the movies field.
func (r *queryResolver) Movies(ctx context.Context) ([]*model.Movie, error) {
	panic(fmt.Errorf("not implemented: Movies - movies"))
}

// Movie is the resolver for the movie field.
func (r *queryResolver) Movie(ctx context.Context, id string) (*model.Movie, error) {
	panic(fmt.Errorf("not implemented: Movie - movie"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Me - me"))
}

// Actors is the resolver for the actors field.
func (r *queryResolver) Actors(ctx context.Context) ([]*model.Actor, error) {
	var actors []models.Actors
	if err := config.DB.Find(&actors).Error; err != nil {
		return nil, err
	}
	var result []*model.Actor
	for _, a := range actors {
		result = append(result, &model.Actor{ID: fmt.Sprint(a.ID), Name: a.Name, Photo: a.Photo})
	}
	return result, nil
}

// Actor is the resolver for the actor field.
func (r *queryResolver) Actor(ctx context.Context, id string) (*model.Actor, error) {
	var actor models.Actors
	if err := config.DB.First(&actor, id).Error; err != nil {
		return nil, err
	}
	return &model.Actor{ID: fmt.Sprint(actor.ID), Name: actor.Name, Photo: actor.Photo}, nil
}

// Genres is the resolver for the genres field.
func (r *queryResolver) Genres(ctx context.Context) ([]*model.Genre, error) {
	panic(fmt.Errorf("not implemented: Genres - genres"))
}

// Genre is the resolver for the genre field.
func (r *queryResolver) Genre(ctx context.Context, id string) (*model.Genre, error) {
	panic(fmt.Errorf("not implemented: Genre - genre"))
}

// Broadcasts is the resolver for the broadcasts field.
func (r *queryResolver) Broadcasts(ctx context.Context) ([]*model.Broadcast, error) {
	panic(fmt.Errorf("not implemented: Broadcasts - broadcasts"))
}

// Broadcast is the resolver for the broadcast field.
func (r *queryResolver) Broadcast(ctx context.Context, id string) (*model.Broadcast, error) {
	panic(fmt.Errorf("not implemented: Broadcast - broadcast"))
}

// Statuses is the resolver for the statuses field.
func (r *queryResolver) Statuses(ctx context.Context) ([]*model.Status, error) {
	panic(fmt.Errorf("not implemented: Statuses - statuses"))
}

// Status is the resolver for the status field.
func (r *queryResolver) Status(ctx context.Context, id string) (*model.Status, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
*/
