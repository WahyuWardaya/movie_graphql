package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"errors"
	"fmt"
	"movie_api/config"
	"movie_api/graph/model"
	"movie_api/models"
	"movie_api/utils"
	"strings"

	"golang.org/x/crypto/bcrypt"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	// Validasi confirm password
	if input.Password != input.ConfirmPassword {
		return nil, errors.New("password dan confirm password tidak sama")
	}

	// Cek apakah email sudah digunakan
	var existing models.Users
	if err := config.DB.Where("users_email = ?", input.Email).First(&existing).Error; err == nil {
		return nil, errors.New("email sudah digunakan")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, errors.New("gagal hash password")
	}

	// Buat user baru
	newUser := models.Users{
		Name:     input.Name,
		Email:    input.Email,
		Password: string(hashedPassword),
		IDRoles:  uint(input.RoleID), // <- tetap gunakan input.RoleId agar fleksibel
	}

	if err := config.DB.Create(&newUser).Error; err != nil {
		return nil, errors.New("gagal menyimpan user")
	}

	// Ambil data role
	var role models.Roles
	if err := config.DB.First(&role, newUser.IDRoles).Error; err != nil {
		return nil, errors.New("gagal mengambil data role")
	}

	// Generate JWT
	token, err := utils.GenerateJWT(newUser.ID, newUser.Email, role.Name)
	if err != nil {
		return nil, errors.New("gagal membuat token")
	}

	// Kembalikan response
	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:    fmt.Sprintf("%d", newUser.ID),
			Name:  newUser.Name,
			Email: newUser.Email,
			Role: &model.Role{
				ID:   fmt.Sprintf("%d", role.ID),
				Name: role.Name,
			},
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthResponse, error) {
	var user models.Users

	// Cari user berdasarkan email
	if err := config.DB.Where("users_email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("email tidak ditemukan")
	}

	// Cek password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return nil, errors.New("password salah")
	}

	// Ambil role
	var role models.Roles
	if err := config.DB.First(&role, user.IDRoles).Error; err != nil {
		return nil, errors.New("gagal ambil role")
	}

	// Generate token
	token, err := utils.GenerateJWT(user.ID, user.Email, role.Name)
	if err != nil {
		return nil, errors.New("gagal membuat token")
	}

	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:    fmt.Sprint(user.ID),
			Name:  user.Name,
			Email: user.Email,
			Role: &model.Role{
				ID:   fmt.Sprint(role.ID),
				Name: role.Name,
			},
		},
	}, nil
}

// CreateActor is the resolver for the createActor field.
func (r *mutationResolver) CreateActor(ctx context.Context, input model.NewActor) (*model.Actor, error) {
	actor := models.Actors{Name: input.Name}
	if input.Photo != nil {
		actor.Photo = *input.Photo
	}
	if err := config.DB.Create(&actor).Error; err != nil {
		return nil, err
	}

	return &model.Actor{
		ID:    fmt.Sprint(actor.ID),
		Name:  actor.Name,
		Photo: actor.Photo, // âœ… kembalikan ke client
	}, nil
}

// CreateActors is the resolver for the createActors field.
func (r *mutationResolver) CreateActors(ctx context.Context, inputs []*model.NewActor) ([]*model.Actor, error) {
	var createdActors []*model.Actor

	for _, input := range inputs {
		actor := models.Actors{Name: input.Name}
		if input.Photo != nil {
			actor.Photo = *input.Photo
		}

		if err := config.DB.Create(&actor).Error; err != nil {
			return nil, err
		}

		createdActors = append(createdActors, &model.Actor{
			ID:    fmt.Sprint(actor.ID),
			Name:  actor.Name,
			Photo: actor.Photo,
		})
	}

	return createdActors, nil
}

// UpdateActor is the resolver for the updateActor field.
func (r *mutationResolver) UpdateActor(ctx context.Context, id string, input model.NewActor) (*model.Actor, error) {
	var actor models.Actors
	if err := config.DB.First(&actor, id).Error; err != nil {
		return nil, err
	}

	actor.Name = input.Name
	if input.Photo != nil {
		actor.Photo = *input.Photo
	}

	if err := config.DB.Save(&actor).Error; err != nil {
		return nil, err
	}

	return &model.Actor{
		ID:    fmt.Sprint(actor.ID),
		Name:  actor.Name,
		Photo: actor.Photo,
	}, nil
}

// DeleteActor is the resolver for the deleteActor field.
func (r *mutationResolver) DeleteActor(ctx context.Context, id string) (bool, error) {
	if err := config.DB.Delete(&models.Actors{}, id).Error; err != nil {
		return false, err
	}
	return true, nil
}

// CreateGenre is the resolver for the createGenre field.
func (r *mutationResolver) CreateGenre(ctx context.Context, input model.NewGenre) (*model.Genre, error) {
	genre := models.Genres{Genres: input.Name}
	if err := config.DB.Create(&genre).Error; err != nil {
		return nil, err
	}
	return &model.Genre{ID: fmt.Sprint(genre.ID), Name: genre.Genres}, nil
}

// UpdateGenre is the resolver for the updateGenre field.
func (r *mutationResolver) UpdateGenre(ctx context.Context, id string, input model.NewGenre) (*model.Genre, error) {
	var genre models.Genres
	if err := config.DB.First(&genre, id).Error; err != nil {
		return nil, err
	}
	genre.Genres = input.Name
	config.DB.Save(&genre)
	return &model.Genre{ID: fmt.Sprint(genre.ID), Name: genre.Genres}, nil
}

// DeleteGenre is the resolver for the deleteGenre field.
func (r *mutationResolver) DeleteGenre(ctx context.Context, id string) (bool, error) {
	if err := config.DB.Delete(&models.Genres{}, id).Error; err != nil {
		return false, err
	}
	return true, nil
}

// CreateMovie is the resolver for the createMovie field.
func (r *mutationResolver) CreateMovie(ctx context.Context, input model.CreateMovieInput) (*model.Movie, error) {
	var statuses []models.Statuses
	if err := config.DB.Where("id_statuses IN ?", input.StatusIDs).Find(&statuses).Error; err != nil {
		return nil, err
	}

	isComingSoon := false
	for _, s := range statuses {
		if strings.ToLower(s.Name) == "coming soon" {
			isComingSoon = true
			break
		}
	}

	if !isComingSoon {
		if input.Rating == nil || input.Duration == nil {
			return nil, errors.New("rating dan duration wajib jika bukan Coming Soon")
		}
	}

	movie := models.Movies{
		Name:        input.Title,
		Description: input.Description,
		Views: func() int {
			if input.Views != nil {
				return int(*input.Views)
			}
			return 0
		}(),
	}

	// Tambahkan jika ada nilai
	if input.Rating != nil {
		movie.Rating = float32(*input.Rating)
	}
	if input.Duration != nil {
		movie.Duration = int(*input.Duration)
	}
	if input.Poster != nil {
		movie.Poster = *input.Poster
	}
	if input.Views != nil && *input.Views < 0 {
		return nil, errors.New("views tidak boleh negatif")
	}

	if err := config.DB.Create(&movie).Error; err != nil {
		return nil, err
	}

	// Relasi
	if len(input.GenreIDs) > 0 {
		var genres []models.Genres
		config.DB.Find(&genres, input.GenreIDs)
		config.DB.Model(&movie).Association("Genres").Replace(&genres)
	}
	if len(input.ActorIDs) > 0 {
		var actors []models.Actors
		config.DB.Find(&actors, input.ActorIDs)
		config.DB.Model(&movie).Association("Actors").Replace(&actors)
	}
	if len(input.BroadcastIDs) > 0 {
		var broadcasts []models.Broadcast
		config.DB.Find(&broadcasts, input.BroadcastIDs)
		config.DB.Model(&movie).Association("Broadcast").Replace(&broadcasts)
	}
	if len(input.StatusIDs) > 0 {
		config.DB.Model(&movie).Association("Statuses").Replace(&statuses)
	}

	return MapMovieToGraphQL(movie), nil
}

// UpdateMovie is the resolver for the updateMovie field.
func (r *mutationResolver) UpdateMovie(ctx context.Context, id string, input model.UpdateMovieInput) (*model.Movie, error) {
	var movie models.Movies
	if err := config.DB.
		Preload("Genres").
		Preload("Actors").
		Preload("Broadcast").
		Preload("Statuses").
		First(&movie, id).Error; err != nil {
		return nil, err
	}

	if input.Title != nil {
		movie.Name = *input.Title
	}
	if input.Description != nil {
		movie.Description = *input.Description
	}
	if input.Rating != nil {
		movie.Rating = float32(*input.Rating)
	}
	if input.Duration != nil {
		movie.Duration = int(*input.Duration)
	}
	if input.Poster != nil {
		movie.Poster = *input.Poster
	}
	if input.Views != nil {
		movie.Views = int(*input.Views)
	}

	if err := config.DB.Save(&movie).Error; err != nil {
		return nil, err
	}

	if input.GenreIDs != nil {
		var genres []models.Genres
		config.DB.Find(&genres, input.GenreIDs)
		config.DB.Model(&movie).Association("Genres").Replace(&genres)
	}
	if input.ActorIDs != nil {
		var actors []models.Actors
		config.DB.Find(&actors, input.ActorIDs)
		config.DB.Model(&movie).Association("Actors").Replace(&actors)
	}
	if input.BroadcastIDs != nil {
		var broadcasts []models.Broadcast
		config.DB.Find(&broadcasts, input.BroadcastIDs)
		config.DB.Model(&movie).Association("Broadcast").Replace(&broadcasts)
	}
	if input.StatusIDs != nil {
		var statuses []models.Statuses
		config.DB.Find(&statuses, input.StatusIDs)
		config.DB.Model(&movie).Association("Statuses").Replace(&statuses)
	}

	return MapMovieToGraphQL(movie), nil
}

// DeleteMovie is the resolver for the deleteMovie field.
func (r *mutationResolver) DeleteMovie(ctx context.Context, id string) (bool, error) {
	if err := config.DB.Delete(&models.Movies{}, id).Error; err != nil {
		return false, err
	}
	return true, nil
}

// CreateBroadcast is the resolver for the createBroadcast field.
func (r *mutationResolver) CreateBroadcast(ctx context.Context, input model.NewBroadcast) (*model.Broadcast, error) {
	broadcast := models.Broadcast{
		Name: input.Name,
		Link: input.Link,
	}
	if err := config.DB.Create(&broadcast).Error; err != nil {
		return nil, err
	}
	return &model.Broadcast{
		ID:   fmt.Sprint(broadcast.ID),
		Name: broadcast.Name,
		Link: broadcast.Link,
	}, nil
}

// UpdateBroadcast is the resolver for the updateBroadcast field.
func (r *mutationResolver) UpdateBroadcast(ctx context.Context, id string, input model.NewBroadcast) (*model.Broadcast, error) {
	var broadcast models.Broadcast
	if err := config.DB.First(&broadcast, id).Error; err != nil {
		return nil, err
	}
	broadcast.Name = input.Name
	if err := config.DB.Save(&broadcast).Error; err != nil {
		return nil, err
	}
	return &model.Broadcast{ID: fmt.Sprint(broadcast.ID), Name: broadcast.Name}, nil
}

// DeleteBroadcast is the resolver for the deleteBroadcast field.
func (r *mutationResolver) DeleteBroadcast(ctx context.Context, id string) (bool, error) {
	if err := config.DB.Delete(&models.Broadcast{}, id).Error; err != nil {
		return false, err
	}
	return true, nil
}

// Movies is the resolver for the movies field.
func (r *queryResolver) Movies(ctx context.Context) ([]*model.Movie, error) {
	var movies []models.Movies
	if err := config.DB.
		Preload("Genres").
		Preload("Actors").
		Preload("Broadcast").
		Preload("Statuses").
		Find(&movies).Error; err != nil {
		return nil, err
	}

	var result []*model.Movie
	for _, m := range movies {
		result = append(result, MapMovieToGraphQL(m))
	}
	return result, nil
}

// Movie is the resolver for the movie field.
func (r *queryResolver) Movie(ctx context.Context, id string) (*model.Movie, error) {
	var movie models.Movies
	if err := config.DB.
		Preload("Genres").
		Preload("Actors").
		Preload("Broadcast").
		Preload("Statuses").
		First(&movie, id).Error; err != nil {
		return nil, err
	}

	return MapMovieToGraphQL(movie), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Me - me"))
}

// Actors is the resolver for the actors field.
func (r *queryResolver) Actors(ctx context.Context) ([]*model.Actor, error) {
	var actors []models.Actors
	if err := config.DB.Find(&actors).Error; err != nil {
		return nil, err
	}
	var result []*model.Actor
	for _, a := range actors {
		result = append(result, &model.Actor{ID: fmt.Sprint(a.ID), Name: a.Name, Photo: a.Photo})
	}
	return result, nil
}

// Actor is the resolver for the actor field.
func (r *queryResolver) Actor(ctx context.Context, id string) (*model.Actor, error) {
	var actor models.Actors
	if err := config.DB.First(&actor, id).Error; err != nil {
		return nil, err
	}
	return &model.Actor{ID: fmt.Sprint(actor.ID), Name: actor.Name, Photo: actor.Photo}, nil
}

// Genres is the resolver for the genres field. menampung data genre
func (r *queryResolver) Genres(ctx context.Context) ([]*model.Genre, error) {
	var genres []models.Genres
	if err := config.DB.Find(&genres).Error; err != nil {
		return nil, err
	}
	var result []*model.Genre
	for _, g := range genres {
		result = append(result, &model.Genre{ID: fmt.Sprint(g.ID), Name: g.Genres})
	}
	return result, nil
}

// Genre is the resolver for the genre field. memanggil data
func (r *queryResolver) Genre(ctx context.Context, id string) (*model.Genre, error) {
	var genre models.Genres
	if err := config.DB.First(&genre, id).Error; err != nil {
		return nil, err
	}
	return &model.Genre{ID: fmt.Sprint(genre.ID), Name: genre.Genres}, nil
}

// Broadcasts is the resolver for the broadcasts field.
func (r *queryResolver) Broadcasts(ctx context.Context) ([]*model.Broadcast, error) {
	var broadcasts []models.Broadcast
	if err := config.DB.Find(&broadcasts).Error; err != nil {
		return nil, err
	}
	var result []*model.Broadcast
	for _, b := range broadcasts {
		result = append(result, &model.Broadcast{ID: fmt.Sprint(b.ID), Name: b.Name})
	}
	return result, nil
}

// Broadcast is the resolver for the broadcast field.
func (r *queryResolver) Broadcast(ctx context.Context, id string) (*model.Broadcast, error) {
	var broadcast models.Broadcast
	if err := config.DB.First(&broadcast, id).Error; err != nil {
		return nil, err
	}
	return &model.Broadcast{ID: fmt.Sprint(broadcast.ID), Name: broadcast.Name}, nil
}

// Statuses is the resolver for the statuses field.
func (r *queryResolver) Statuses(ctx context.Context) ([]*model.Status, error) {
	panic(fmt.Errorf("not implemented: Statuses - statuses"))
}

// Status is the resolver for the status field.
func (r *queryResolver) Status(ctx context.Context, id string) (*model.Status, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
*/
